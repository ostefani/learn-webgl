<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>WebGL Coordinate Spaces Visualization</title>
        <style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
                margin: 0;
                padding: 0;
                background-color: #f0f0f0;
                color: #333;
                overflow: hidden;
            }
            .container {
                display: flex;
                height: 100vh;
            }
            .canvas-container {
                flex: 1;
                position: relative;
            }
            #glCanvas {
                display: block;
                width: 100%;
                height: 100%;
                background-color: #222;
            }
            .controls {
                width: 320px;
                padding: 20px;
                background-color: #fff;
                box-shadow: -2px 0 10px rgba(0, 0, 0, 0.1);
                overflow-y: auto;
            }
            .control-group {
                margin-bottom: 20px;
                border-bottom: 1px solid #eee;
                padding-bottom: 15px;
            }
            h1 {
                font-size: 18px;
                margin: 0 0 15px 0;
            }
            h2 {
                font-size: 16px;
                margin: 0 0 10px 0;
            }
            p {
                margin: 5px 0;
                font-size: 14px;
                line-height: 1.4;
            }
            label {
                display: block;
                margin: 10px 0 5px 0;
                font-weight: bold;
                font-size: 14px;
            }
            input[type='range'] {
                width: 100%;
            }
            .matrix-display {
                font-family: monospace;
                font-size: 12px;
                background-color: #f8f8f8;
                padding: 10px;
                border: 1px solid #ddd;
                margin-top: 10px;
                white-space: pre;
                overflow-x: auto;
            }
            .space-indicator {
                position: absolute;
                padding: 5px 10px;
                background-color: rgba(0, 0, 0, 0.7);
                color: white;
                font-size: 12px;
                border-radius: 4px;
                pointer-events: none;
            }
            button {
                padding: 8px 12px;
                background-color: #4a6dff;
                color: white;
                border: none;
                border-radius: 4px;
                cursor: pointer;
                margin-right: 5px;
                margin-bottom: 5px;
            }
            button:hover {
                background-color: #3a5cee;
            }
            .coordinate-spaces button {
                background-color: #555;
            }
            .coordinate-spaces button.active {
                background-color: #4a6dff;
            }
            .axis {
                position: absolute;
                font-weight: bold;
                font-size: 14px;
                pointer-events: none;
            }
            .x-axis {
                color: #ff5555;
            }
            .y-axis {
                color: #55ff55;
            }
            .z-axis {
                color: #5555ff;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div class="canvas-container">
                <canvas id="glCanvas"></canvas>
                <div id="spaceIndicator" class="space-indicator">Model Space</div>
            </div>
            <div class="controls">
                <div class="control-group">
                    <h1>WebGL Coordinate Spaces Demo</h1>
                    <p>
                        This demo visualizes how 3D models are transformed through different coordinate spaces in the
                        WebGL pipeline.
                    </p>
                </div>

                <div class="control-group coordinate-spaces">
                    <h2>Coordinate Space</h2>
                    <p>Select which coordinate space to visualize:</p>
                    <div>
                        <button id="modelSpace" class="active">Model Space</button>
                        <button id="worldSpace">World Space</button>
                        <button id="viewSpace">View Space</button>
                        <button id="clipSpace">Clip Space</button>
                        <button id="ndcSpace">NDC Space</button>
                    </div>
                </div>

                <div class="control-group">
                    <h2>Model Transforms</h2>
                    <label for="modelRotateX">Rotate X: <span id="modelRotateXValue">0째</span></label>
                    <input type="range" id="modelRotateX" min="-180" max="180" value="0" step="1" />

                    <label for="modelRotateY">Rotate Y: <span id="modelRotateYValue">0째</span></label>
                    <input type="range" id="modelRotateY" min="-180" max="180" value="0" step="1" />

                    <label for="modelRotateZ">Rotate Z: <span id="modelRotateZValue">0째</span></label>
                    <input type="range" id="modelRotateZ" min="-180" max="180" value="0" step="1" />

                    <label for="modelTranslateX">Translate X: <span id="modelTranslateXValue">0</span></label>
                    <input type="range" id="modelTranslateX" min="-5" max="5" value="0" step="0.1" />

                    <label for="modelTranslateY">Translate Y: <span id="modelTranslateYValue">0</span></label>
                    <input type="range" id="modelTranslateY" min="-5" max="5" value="0" step="0.1" />

                    <label for="modelTranslateZ">Translate Z: <span id="modelTranslateZValue">0</span></label>
                    <input type="range" id="modelTranslateZ" min="-5" max="5" value="0" step="0.1" />

                    <label for="modelScale">Scale: <span id="modelScaleValue">1.0</span></label>
                    <input type="range" id="modelScale" min="0.1" max="2" value="1" step="0.1" />
                </div>

                <div class="control-group">
                    <h2>Camera/View</h2>
                    <label for="cameraPositionX">Camera X: <span id="cameraPositionXValue">3</span></label>
                    <input type="range" id="cameraPositionX" min="-10" max="10" value="3" step="0.1" />

                    <label for="cameraPositionY">Camera Y: <span id="cameraPositionYValue">3</span></label>
                    <input type="range" id="cameraPositionY" min="-10" max="10" value="3" step="0.1" />

                    <label for="cameraPositionZ">Camera Z: <span id="cameraPositionZValue">5</span></label>
                    <input type="range" id="cameraPositionZ" min="1" max="15" value="5" step="0.1" />

                    <label for="cameraTargetX">Look At X: <span id="cameraTargetXValue">0</span></label>
                    <input type="range" id="cameraTargetX" min="-5" max="5" value="0" step="0.1" />

                    <label for="cameraTargetY">Look At Y: <span id="cameraTargetYValue">0</span></label>
                    <input type="range" id="cameraTargetY" min="-5" max="5" value="0" step="0.1" />

                    <label for="cameraTargetZ">Look At Z: <span id="cameraTargetZValue">0</span></label>
                    <input type="range" id="cameraTargetZ" min="-5" max="5" value="0" step="0.1" />
                </div>

                <div class="control-group">
                    <h2>Projection</h2>
                    <div>
                        <button id="perspectiveProjection" class="active">Perspective</button>
                        <button id="orthographicProjection">Orthographic</button>
                    </div>

                    <label for="fieldOfView">Field of View: <span id="fieldOfViewValue">45째</span></label>
                    <input type="range" id="fieldOfView" min="10" max="120" value="45" step="1" />

                    <label for="nearPlane">Near Plane: <span id="nearPlaneValue">0.1</span></label>
                    <input type="range" id="nearPlane" min="0.1" max="10" value="0.1" step="0.1" />

                    <label for="farPlane">Far Plane: <span id="farPlaneValue">100</span></label>
                    <input type="range" id="farPlane" min="10" max="200" value="100" step="1" />
                </div>

                <div class="control-group">
                    <h2>Visualization Options</h2>
                    <div>
                        <button id="toggleAxes" class="active">Show Axes</button>
                        <button id="toggleCube">Show Cube</button>
                        <button id="toggleClipVolume" class="active">Show Clip Volume</button>
                        <button id="toggleWireframe">Wireframe</button>
                        <button id="toggleBackfaceCulling" class="active">Backface Culling</button>
                    </div>
                </div>

                <div class="control-group">
                    <h2>Current Transform Matrix</h2>
                    <div class="matrix-display" id="matrixDisplay">Matrix will be shown here</div>
                </div>
            </div>
        </div>

        <script>
            // Utility functions for matrix operations
            const mat4 = {
                create: function () {
                    return new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
                },
                multiply: function (out, a, b) {
                    const a00 = a[0],
                        a01 = a[1],
                        a02 = a[2],
                        a03 = a[3],
                        a10 = a[4],
                        a11 = a[5],
                        a12 = a[6],
                        a13 = a[7],
                        a20 = a[8],
                        a21 = a[9],
                        a22 = a[10],
                        a23 = a[11],
                        a30 = a[12],
                        a31 = a[13],
                        a32 = a[14],
                        a33 = a[15];

                    let b0 = b[0],
                        b1 = b[1],
                        b2 = b[2],
                        b3 = b[3];
                    out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
                    out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
                    out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
                    out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

                    b0 = b[4];
                    b1 = b[5];
                    b2 = b[6];
                    b3 = b[7];
                    out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
                    out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
                    out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
                    out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

                    b0 = b[8];
                    b1 = b[9];
                    b2 = b[10];
                    b3 = b[11];
                    out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
                    out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
                    out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
                    out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

                    b0 = b[12];
                    b1 = b[13];
                    b2 = b[14];
                    b3 = b[15];
                    out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
                    out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
                    out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
                    out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
                    return out;
                },
                translate: function (out, a, v) {
                    const x = v[0],
                        y = v[1],
                        z = v[2];

                    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
                    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
                    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
                    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];

                    return out;
                },
                scale: function (out, a, v) {
                    const x = v[0],
                        y = v[1],
                        z = v[2];

                    out[0] = a[0] * x;
                    out[1] = a[1] * x;
                    out[2] = a[2] * x;
                    out[3] = a[3] * x;
                    out[4] = a[4] * y;
                    out[5] = a[5] * y;
                    out[6] = a[6] * y;
                    out[7] = a[7] * y;
                    out[8] = a[8] * z;
                    out[9] = a[9] * z;
                    out[10] = a[10] * z;
                    out[11] = a[11] * z;

                    return out;
                },
                rotateX: function (out, a, rad) {
                    const s = Math.sin(rad),
                        c = Math.cos(rad),
                        a10 = a[4],
                        a11 = a[5],
                        a12 = a[6],
                        a13 = a[7],
                        a20 = a[8],
                        a21 = a[9],
                        a22 = a[10],
                        a23 = a[11];

                    // Perform axis-specific matrix multiplication
                    out[4] = a10 * c + a20 * s;
                    out[5] = a11 * c + a21 * s;
                    out[6] = a12 * c + a22 * s;
                    out[7] = a13 * c + a23 * s;
                    out[8] = a20 * c - a10 * s;
                    out[9] = a21 * c - a11 * s;
                    out[10] = a22 * c - a12 * s;
                    out[11] = a23 * c - a13 * s;

                    return out;
                },
                rotateY: function (out, a, rad) {
                    const s = Math.sin(rad),
                        c = Math.cos(rad),
                        a00 = a[0],
                        a01 = a[1],
                        a02 = a[2],
                        a03 = a[3],
                        a20 = a[8],
                        a21 = a[9],
                        a22 = a[10],
                        a23 = a[11];

                    // Perform axis-specific matrix multiplication
                    out[0] = a00 * c - a20 * s;
                    out[1] = a01 * c - a21 * s;
                    out[2] = a02 * c - a22 * s;
                    out[3] = a03 * c - a23 * s;
                    out[8] = a00 * s + a20 * c;
                    out[9] = a01 * s + a21 * c;
                    out[10] = a02 * s + a22 * c;
                    out[11] = a03 * s + a23 * c;

                    return out;
                },
                rotateZ: function (out, a, rad) {
                    const s = Math.sin(rad),
                        c = Math.cos(rad),
                        a00 = a[0],
                        a01 = a[1],
                        a02 = a[2],
                        a03 = a[3],
                        a10 = a[4],
                        a11 = a[5],
                        a12 = a[6],
                        a13 = a[7];

                    // Perform axis-specific matrix multiplication
                    out[0] = a00 * c + a10 * s;
                    out[1] = a01 * c + a11 * s;
                    out[2] = a02 * c + a12 * s;
                    out[3] = a03 * c + a13 * s;
                    out[4] = a10 * c - a00 * s;
                    out[5] = a11 * c - a01 * s;
                    out[6] = a12 * c - a02 * s;
                    out[7] = a13 * c - a03 * s;

                    return out;
                },
                perspective: function (out, fovy, aspect, near, far) {
                    const f = 1.0 / Math.tan(fovy / 2),
                        nf = 1 / (near - far);

                    out[0] = f / aspect;
                    out[1] = 0;
                    out[2] = 0;
                    out[3] = 0;
                    out[4] = 0;
                    out[5] = f;
                    out[6] = 0;
                    out[7] = 0;
                    out[8] = 0;
                    out[9] = 0;
                    out[10] = (far + near) * nf;
                    out[11] = -1;
                    out[12] = 0;
                    out[13] = 0;
                    out[14] = 2 * far * near * nf;
                    out[15] = 0;

                    return out;
                },
                ortho: function (out, left, right, bottom, top, near, far) {
                    const lr = 1 / (left - right),
                        bt = 1 / (bottom - top),
                        nf = 1 / (near - far);

                    out[0] = -2 * lr;
                    out[1] = 0;
                    out[2] = 0;
                    out[3] = 0;
                    out[4] = 0;
                    out[5] = -2 * bt;
                    out[6] = 0;
                    out[7] = 0;
                    out[8] = 0;
                    out[9] = 0;
                    out[10] = 2 * nf;
                    out[11] = 0;
                    out[12] = (left + right) * lr;
                    out[13] = (top + bottom) * bt;
                    out[14] = (far + near) * nf;
                    out[15] = 1;

                    return out;
                },
                lookAt: function (out, eye, center, up) {
                    let x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
                    const eyex = eye[0];
                    const eyey = eye[1];
                    const eyez = eye[2];
                    const upx = up[0];
                    const upy = up[1];
                    const upz = up[2];
                    const centerx = center[0];
                    const centery = center[1];
                    const centerz = center[2];

                    if (
                        Math.abs(eyex - centerx) < 0.000001 &&
                        Math.abs(eyey - centery) < 0.000001 &&
                        Math.abs(eyez - centerz) < 0.000001
                    ) {
                        return mat4.identity(out);
                    }

                    z0 = eyex - centerx;
                    z1 = eyey - centery;
                    z2 = eyez - centerz;

                    len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
                    z0 *= len;
                    z1 *= len;
                    z2 *= len;

                    x0 = upy * z2 - upz * z1;
                    x1 = upz * z0 - upx * z2;
                    x2 = upx * z1 - upy * z0;
                    len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
                    if (!len) {
                        x0 = 0;
                        x1 = 0;
                        x2 = 0;
                    } else {
                        len = 1 / len;
                        x0 *= len;
                        x1 *= len;
                        x2 *= len;
                    }

                    y0 = z1 * x2 - z2 * x1;
                    y1 = z2 * x0 - z0 * x2;
                    y2 = z0 * x1 - z1 * x0;

                    len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
                    if (!len) {
                        y0 = 0;
                        y1 = 0;
                        y2 = 0;
                    } else {
                        len = 1 / len;
                        y0 *= len;
                        y1 *= len;
                        y2 *= len;
                    }

                    out[0] = x0;
                    out[1] = y0;
                    out[2] = z0;
                    out[3] = 0;
                    out[4] = x1;
                    out[5] = y1;
                    out[6] = z1;
                    out[7] = 0;
                    out[8] = x2;
                    out[9] = y2;
                    out[10] = z2;
                    out[11] = 0;
                    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
                    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
                    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
                    out[15] = 1;

                    return out;
                },
                formatForDisplay: function (m) {
                    function formatNumber(n) {
                        return Math.abs(n) < 0.0001 ? '0.000' : n.toFixed(3);
                    }

                    return [
                        `| ${formatNumber(m[0])} ${formatNumber(m[4])} ${formatNumber(m[8])} ${formatNumber(m[12])} |`,
                        `| ${formatNumber(m[1])} ${formatNumber(m[5])} ${formatNumber(m[9])} ${formatNumber(m[13])} |`,
                        `| ${formatNumber(m[2])} ${formatNumber(m[6])} ${formatNumber(m[10])} ${formatNumber(m[14])} |`,
                        `| ${formatNumber(m[3])} ${formatNumber(m[7])} ${formatNumber(m[11])} ${formatNumber(m[15])} |`,
                    ].join('\n');
                },
            };

            // WebGL code
            const vertexShaderSource = `
      attribute vec4 aPosition;
      attribute vec4 aColor;
      
      uniform mat4 uModelMatrix;
      uniform mat4 uViewMatrix;
      uniform mat4 uProjectionMatrix;
      uniform int uCoordinateSpace;
      
      varying vec4 vColor;
      varying float vClipW;
      
      void main() {
        // Calculate positions in different coordinate spaces
        vec4 modelPosition = aPosition;
        vec4 worldPosition = uModelMatrix * modelPosition;
        vec4 viewPosition = uViewMatrix * worldPosition;
        vec4 clipPosition = uProjectionMatrix * viewPosition;
        
        vColor = aColor;
        vClipW = clipPosition.w;
        
        // Output position based on selected coordinate space
        if (uCoordinateSpace == 0) {
          // Model space
          gl_Position = uProjectionMatrix * uViewMatrix * modelPosition;
        } else if (uCoordinateSpace == 1) {
          // World space
          gl_Position = uProjectionMatrix * uViewMatrix * mat4(1.0) * worldPosition;
        } else if (uCoordinateSpace == 2) {
          // View space
          gl_Position = uProjectionMatrix * viewPosition;
        } else if (uCoordinateSpace == 3) {
          // Clip space (just pass through)
          gl_Position = clipPosition;
        } else if (uCoordinateSpace == 4) {
          // NDC space (manually perform perspective division)
          gl_Position = clipPosition / clipPosition.w;
        } else {
          gl_Position = clipPosition;
        }
      }
    `;

            const fragmentShaderSource = `
      precision mediump float;
      
      varying vec4 vColor;
      varying float vClipW;
      
      void main() {
        gl_FragColor = vColor;
      }
    `;

            // Main program
            window.onload = function () {
                // WebGL context setup
                const canvas = document.getElementById('glCanvas');
                const gl = canvas.getContext('webgl');

                if (!gl) {
                    alert('WebGL not supported in your browser!');
                    return;
                }

                // Resize canvas to fit container
                function resizeCanvas() {
                    const container = canvas.parentElement;
                    canvas.width = container.clientWidth;
                    canvas.height = container.clientHeight;
                    gl.viewport(0, 0, canvas.width, canvas.height);
                }

                window.addEventListener('resize', resizeCanvas);
                resizeCanvas();

                // Compile shaders
                function compileShader(source, type) {
                    const shader = gl.createShader(type);
                    gl.shaderSource(shader, source);
                    gl.compileShader(shader);

                    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                        console.error('Shader compilation error:', gl.getShaderInfoLog(shader));
                        gl.deleteShader(shader);
                        return null;
                    }

                    return shader;
                }

                const vertexShader = compileShader(vertexShaderSource, gl.VERTEX_SHADER);
                const fragmentShader = compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);

                // Create program
                const program = gl.createProgram();
                gl.attachShader(program, vertexShader);
                gl.attachShader(program, fragmentShader);
                gl.linkProgram(program);

                if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                    console.error('Program linking error:', gl.getProgramInfoLog(program));
                    return;
                }

                // Get shader attributes and uniforms
                const aPosition = gl.getAttribLocation(program, 'aPosition');
                const aColor = gl.getAttribLocation(program, 'aColor');
                const uModelMatrix = gl.getUniformLocation(program, 'uModelMatrix');
                const uViewMatrix = gl.getUniformLocation(program, 'uViewMatrix');
                const uProjectionMatrix = gl.getUniformLocation(program, 'uProjectionMatrix');
                const uCoordinateSpace = gl.getUniformLocation(program, 'uCoordinateSpace');

                // Create a cube
                const cubeVertices = [
                    // Front face
                    -0.5,
                    -0.5,
                    0.5,
                    1.0,
                    0.0,
                    0.0,
                    1.0, // bottom-left, red
                    0.5,
                    -0.5,
                    0.5,
                    1.0,
                    0.5,
                    0.0,
                    1.0, // bottom-right, orange
                    0.5,
                    0.5,
                    0.5,
                    1.0,
                    1.0,
                    0.0,
                    1.0, // top-right, yellow
                    -0.5,
                    0.5,
                    0.5,
                    0.5,
                    1.0,
                    0.0,
                    1.0, // top-left, lime

                    // Back face
                    -0.5,
                    -0.5,
                    -0.5,
                    0.0,
                    1.0,
                    0.0,
                    1.0, // bottom-left, green
                    0.5,
                    -0.5,
                    -0.5,
                    0.0,
                    1.0,
                    0.5,
                    1.0, // bottom-right, teal
                    0.5,
                    0.5,
                    -0.5,
                    0.0,
                    1.0,
                    1.0,
                    1.0, // top-right, cyan
                    -0.5,
                    0.5,
                    -0.5,
                    0.0,
                    0.5,
                    1.0,
                    1.0, // top-left, light blue
                ];

                const cubeIndices = [
                    0,
                    1,
                    2,
                    0,
                    2,
                    3, // front
                    4,
                    5,
                    6,
                    4,
                    6,
                    7, // back
                    0,
                    4,
                    7,
                    0,
                    7,
                    3, // left
                    1,
                    5,
                    6,
                    1,
                    6,
                    2, // right
                    3,
                    2,
                    6,
                    3,
                    6,
                    7, // top
                    0,
                    1,
                    5,
                    0,
                    5,
                    4, // bottom
                ];

                // Create a wire cube (clip volume visualization)
                const clipCubeVertices = [
                    // Front face
                    -1.0,
                    -1.0,
                    1.0,
                    1.0,
                    1.0,
                    1.0,
                    0.5, // bottom-left, white
                    1.0,
                    -1.0,
                    1.0,
                    1.0,
                    1.0,
                    1.0,
                    0.5, // bottom-right, white
                    1.0,
                    1.0,
                    1.0,
                    1.0,
                    1.0,
                    1.0,
                    0.5, // top-right, white
                    -1.0,
                    1.0,
                    1.0,
                    1.0,
                    1.0,
                    1.0,
                    0.5, // top-left, white

                    // Back face
                    -1.0,
                    -1.0,
                    -1.0,
                    1.0,
                    1.0,
                    1.0,
                    0.5, // bottom-left, white
                    1.0,
                    -1.0,
                    -1.0,
                    1.0,
                    1.0,
                    1.0,
                    0.5, // bottom-right, white
                    1.0,
                    1.0,
                    -1.0,
                    1.0,
                    1.0,
                    1.0,
                    0.5, // top-right, white
                    -1.0,
                    1.0,
                    -1.0,
                    1.0,
                    1.0,
                    1.0,
                    0.5, // top-left, white
                ];

                const clipCubeIndices = [
                    0,
                    1,
                    1,
                    2,
                    2,
                    3,
                    3,
                    0, // front face
                    4,
                    5,
                    5,
                    6,
                    6,
                    7,
                    7,
                    4, // back face
                    0,
                    4,
                    1,
                    5,
                    2,
                    6,
                    3,
                    7, // connecting edges
                ];

                // Create coordinate axes
                const axesVertices = [
                    // X axis (red)
                    0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1,

                    // Y axis (green)
                    0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1,

                    // Z axis (blue)
                    0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1,
                ];

                const axesIndices = [
                    0,
                    1, // X axis
                    2,
                    3, // Y axis
                    4,
                    5, // Z axis
                ];

                // Buffer setup
                function createBuffer(data, type) {
                    const buffer = gl.createBuffer();
                    gl.bindBuffer(type, buffer);
                    gl.bufferData(type, data, gl.STATIC_DRAW);
                    return buffer;
                }

                // Cube buffers
                const cubeVertexBuffer = createBuffer(new Float32Array(cubeVertices), gl.ARRAY_BUFFER);
                const cubeIndexBuffer = createBuffer(new Uint16Array(cubeIndices), gl.ELEMENT_ARRAY_BUFFER);
                const cubeVertexCount = cubeIndices.length;

                // Clip cube buffers
                const clipCubeVertexBuffer = createBuffer(new Float32Array(clipCubeVertices), gl.ARRAY_BUFFER);
                const clipCubeIndexBuffer = createBuffer(new Uint16Array(clipCubeIndices), gl.ELEMENT_ARRAY_BUFFER);
                const clipCubeVertexCount = clipCubeIndices.length;

                // Axes buffers
                const axesVertexBuffer = createBuffer(new Float32Array(axesVertices), gl.ARRAY_BUFFER);
                const axesIndexBuffer = createBuffer(new Uint16Array(axesIndices), gl.ELEMENT_ARRAY_BUFFER);
                const axesVertexCount = axesIndices.length;

                // State and UI controls
                const state = {
                    coordinateSpace: 0, // 0:Model, 1:World, 2:View, 3:Clip, 4:NDC
                    modelRotateX: 0,
                    modelRotateY: 0,
                    modelRotateZ: 0,
                    modelTranslateX: 0,
                    modelTranslateY: 0,
                    modelTranslateZ: 0,
                    modelScale: 1,
                    cameraPositionX: 3,
                    cameraPositionY: 3,
                    cameraPositionZ: 5,
                    cameraTargetX: 0,
                    cameraTargetY: 0,
                    cameraTargetZ: 0,
                    projectionType: 'perspective', // 'perspective' or 'orthographic'
                    fieldOfView: 45,
                    nearPlane: 0.1,
                    farPlane: 100,
                    showAxes: true,
                    showCube: true,
                    showClipVolume: true,
                    wireframe: false,
                    backfaceCulling: true,
                };

                // UI elements
                const spaceButtons = [
                    document.getElementById('modelSpace'),
                    document.getElementById('worldSpace'),
                    document.getElementById('viewSpace'),
                    document.getElementById('clipSpace'),
                    document.getElementById('ndcSpace'),
                ];

                const projectionButtons = [
                    document.getElementById('perspectiveProjection'),
                    document.getElementById('orthographicProjection'),
                ];

                const toggleButtons = [
                    document.getElementById('toggleAxes'),
                    document.getElementById('toggleCube'),
                    document.getElementById('toggleClipVolume'),
                    document.getElementById('toggleWireframe'),
                    document.getElementById('toggleBackfaceCulling'),
                ];

                const spaceIndicator = document.getElementById('spaceIndicator');
                const matrixDisplay = document.getElementById('matrixDisplay');

                // Set up sliders
                function setupSlider(id, property, valueDisplayId, min, max, multiplier = 1) {
                    const slider = document.getElementById(id);
                    const valueDisplay = document.getElementById(valueDisplayId);

                    slider.value = state[property];
                    valueDisplay.textContent = (state[property] * multiplier).toFixed(1);

                    slider.addEventListener('input', function () {
                        state[property] = parseFloat(this.value);
                        valueDisplay.textContent = (state[property] * multiplier).toFixed(1);
                    });
                }

                setupSlider('modelRotateX', 'modelRotateX', 'modelRotateXValue', -180, 180, 1);
                setupSlider('modelRotateY', 'modelRotateY', 'modelRotateYValue', -180, 180, 1);
                setupSlider('modelRotateZ', 'modelRotateZ', 'modelRotateZValue', -180, 180, 1);
                setupSlider('modelTranslateX', 'modelTranslateX', 'modelTranslateXValue', -5, 5, 1);
                setupSlider('modelTranslateY', 'modelTranslateY', 'modelTranslateYValue', -5, 5, 1);
                setupSlider('modelTranslateZ', 'modelTranslateZ', 'modelTranslateZValue', -5, 5, 1);
                setupSlider('modelScale', 'modelScale', 'modelScaleValue', 0.1, 2, 1);
                setupSlider('cameraPositionX', 'cameraPositionX', 'cameraPositionXValue', -10, 10, 1);
                setupSlider('cameraPositionY', 'cameraPositionY', 'cameraPositionYValue', -10, 10, 1);
                setupSlider('cameraPositionZ', 'cameraPositionZ', 'cameraPositionZValue', 1, 15, 1);
                setupSlider('cameraTargetX', 'cameraTargetX', 'cameraTargetXValue', -5, 5, 1);
                setupSlider('cameraTargetY', 'cameraTargetY', 'cameraTargetYValue', -5, 5, 1);
                setupSlider('cameraTargetZ', 'cameraTargetZ', 'cameraTargetZValue', -5, 5, 1);
                setupSlider('fieldOfView', 'fieldOfView', 'fieldOfViewValue', 10, 120, 1);
                setupSlider('nearPlane', 'nearPlane', 'nearPlaneValue', 0.1, 10, 1);
                setupSlider('farPlane', 'farPlane', 'farPlaneValue', 10, 200, 1);

                // Set up button groups
                function setupButtonGroup(buttons, callback) {
                    buttons.forEach((button, index) => {
                        button.addEventListener('click', function () {
                            buttons.forEach((b) => b.classList.remove('active'));
                            this.classList.add('active');
                            callback(index, this.id);
                        });
                    });
                }

                setupButtonGroup(spaceButtons, (index) => {
                    state.coordinateSpace = index;

                    const spaceNames = ['Model Space', 'World Space', 'View Space', 'Clip Space', 'NDC Space'];
                    spaceIndicator.textContent = spaceNames[index];
                });

                setupButtonGroup(projectionButtons, (index, id) => {
                    state.projectionType = id === 'perspectiveProjection' ? 'perspective' : 'orthographic';
                });

                // Toggle buttons
                document.getElementById('toggleAxes').addEventListener('click', function () {
                    this.classList.toggle('active');
                    state.showAxes = this.classList.contains('active');
                });

                document.getElementById('toggleCube').addEventListener('click', function () {
                    this.classList.toggle('active');
                    state.showCube = this.classList.contains('active');
                });

                document.getElementById('toggleClipVolume').addEventListener('click', function () {
                    this.classList.toggle('active');
                    state.showClipVolume = this.classList.contains('active');
                });

                document.getElementById('toggleWireframe').addEventListener('click', function () {
                    this.classList.toggle('active');
                    state.wireframe = this.classList.contains('active');
                });

                document.getElementById('toggleBackfaceCulling').addEventListener('click', function () {
                    this.classList.toggle('active');
                    state.backfaceCulling = this.classList.contains('active');
                });

                // Rendering function
                function render() {
                    // Clear the canvas
                    gl.clearColor(0.1, 0.1, 0.1, 1.0);
                    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

                    gl.enable(gl.DEPTH_TEST);

                    // Toggle backface culling
                    if (state.backfaceCulling) {
                        gl.enable(gl.CULL_FACE);
                        gl.cullFace(gl.BACK);
                    } else {
                        gl.disable(gl.CULL_FACE);
                    }

                    // Use our shader program
                    gl.useProgram(program);

                    // Create matrices
                    const modelMatrix = mat4.create();
                    mat4.translate(modelMatrix, modelMatrix, [
                        state.modelTranslateX,
                        state.modelTranslateY,
                        state.modelTranslateZ,
                    ]);
                    mat4.rotateX(modelMatrix, modelMatrix, (state.modelRotateX * Math.PI) / 180);
                    mat4.rotateY(modelMatrix, modelMatrix, (state.modelRotateY * Math.PI) / 180);
                    mat4.rotateZ(modelMatrix, modelMatrix, (state.modelRotateZ * Math.PI) / 180);
                    mat4.scale(modelMatrix, modelMatrix, [state.modelScale, state.modelScale, state.modelScale]);

                    const viewMatrix = mat4.create();
                    mat4.lookAt(
                        viewMatrix,
                        [state.cameraPositionX, state.cameraPositionY, state.cameraPositionZ],
                        [state.cameraTargetX, state.cameraTargetY, state.cameraTargetZ],
                        [0, 1, 0]
                    );

                    const projectionMatrix = mat4.create();
                    const aspect = canvas.width / canvas.height;

                    if (state.projectionType === 'perspective') {
                        mat4.perspective(
                            projectionMatrix,
                            (state.fieldOfView * Math.PI) / 180,
                            aspect,
                            state.nearPlane,
                            state.farPlane
                        );
                    } else {
                        const scale = 5;
                        mat4.ortho(
                            projectionMatrix,
                            -scale * aspect,
                            scale * aspect,
                            -scale,
                            scale,
                            state.nearPlane,
                            state.farPlane
                        );
                    }

                    // Set uniforms
                    gl.uniformMatrix4fv(uModelMatrix, false, modelMatrix);
                    gl.uniformMatrix4fv(uViewMatrix, false, viewMatrix);
                    gl.uniformMatrix4fv(uProjectionMatrix, false, projectionMatrix);
                    gl.uniform1i(uCoordinateSpace, state.coordinateSpace);

                    // Show matrix in UI based on current coordinate space
                    if (state.coordinateSpace === 0) {
                        matrixDisplay.textContent = 'Identity Matrix (Model Space)';
                    } else if (state.coordinateSpace === 1) {
                        matrixDisplay.textContent = 'Model Matrix:\n' + mat4.formatForDisplay(modelMatrix);
                    } else if (state.coordinateSpace === 2) {
                        const mvMatrix = mat4.create();
                        mat4.multiply(mvMatrix, viewMatrix, modelMatrix);
                        matrixDisplay.textContent = 'Model-View Matrix:\n' + mat4.formatForDisplay(mvMatrix);
                    } else if (state.coordinateSpace === 3) {
                        const mvpMatrix = mat4.create();
                        const mvMatrix = mat4.create();
                        mat4.multiply(mvMatrix, viewMatrix, modelMatrix);
                        mat4.multiply(mvpMatrix, projectionMatrix, mvMatrix);
                        matrixDisplay.textContent =
                            'Model-View-Projection Matrix:\n' + mat4.formatForDisplay(mvpMatrix);
                    } else if (state.coordinateSpace === 4) {
                        matrixDisplay.textContent = 'NDC Space (after perspective division)';
                    }

                    // Draw methods
                    function drawArrays(vertexBuffer, indexBuffer, vertexCount, drawMode) {
                        // Bind vertex buffer
                        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);

                        // Set up attribute pointers
                        gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 7 * 4, 0);
                        gl.enableVertexAttribArray(aPosition);

                        gl.vertexAttribPointer(aColor, 4, gl.FLOAT, false, 7 * 4, 3 * 4);
                        gl.enableVertexAttribArray(aColor);

                        // Bind index buffer
                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);

                        // Draw
                        gl.drawElements(drawMode, vertexCount, gl.UNSIGNED_SHORT, 0);
                    }

                    // Draw clip volume (NDC cube)
                    if (state.showClipVolume) {
                        drawArrays(clipCubeVertexBuffer, clipCubeIndexBuffer, clipCubeVertexCount, gl.LINES);
                    }

                    // Draw cube
                    if (state.showCube) {
                        drawArrays(
                            cubeVertexBuffer,
                            cubeIndexBuffer,
                            cubeVertexCount,
                            state.wireframe ? gl.LINE_LOOP : gl.TRIANGLES
                        );
                    }

                    // Draw axes
                    if (state.showAxes) {
                        drawArrays(axesVertexBuffer, axesIndexBuffer, axesVertexCount, gl.LINES);
                    }

                    // Request next frame
                    requestAnimationFrame(render);
                }

                // Start rendering
                render();
            };
        </script>
    </body>
</html>
